<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Control register"><title>esp32::sdhost::ctrl - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="esp32" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0-nightly (88269fa9e 2024-02-09) (1.76.0.1)" data-channel="nightly" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../esp32/index.html"><img src="https://avatars.githubusercontent.com/u/46717278" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../esp32/index.html"><img src="https://avatars.githubusercontent.com/u/46717278" alt="logo"></a><h2><a href="../../../esp32/index.html">esp32</a><span class="version">0.29.0</span></h2></div><h2 class="location"><a href="#">Module ctrl</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In esp32::sdhost</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../esp32/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">esp32</a>::<wbr><a href="../index.html">sdhost</a>::<wbr><a class="mod" href="#">ctrl</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/esp32/sdhost/ctrl.rs.html#1-222">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Control register</p>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.CTRL_SPEC.html" title="struct esp32::sdhost::ctrl::CTRL_SPEC">CTRL_SPEC</a></div><div class="desc docblock-short">Control register</div></li></ul><h2 id="types" class="section-header"><a href="#types">Type Aliases</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.ABORT_READ_DATA_R.html" title="type esp32::sdhost::ctrl::ABORT_READ_DATA_R">ABORT_READ_DATA_R</a></div><div class="desc docblock-short">Field <code>ABORT_READ_DATA</code> reader - After a suspend-command is issued during a read-operation, software polls the card to find when the suspend-event occurred. Once the suspend-event has occurred, software sets the bit which will reset the data state machine that is waiting for the next block of data. This bit is automatically cleared once the data state machine is reset to idle.</div></li><li><div class="item-name"><a class="type" href="type.ABORT_READ_DATA_W.html" title="type esp32::sdhost::ctrl::ABORT_READ_DATA_W">ABORT_READ_DATA_W</a></div><div class="desc docblock-short">Field <code>ABORT_READ_DATA</code> writer - After a suspend-command is issued during a read-operation, software polls the card to find when the suspend-event occurred. Once the suspend-event has occurred, software sets the bit which will reset the data state machine that is waiting for the next block of data. This bit is automatically cleared once the data state machine is reset to idle.</div></li><li><div class="item-name"><a class="type" href="type.CEATA_DEVICE_INTERRUPT_STATUS_R.html" title="type esp32::sdhost::ctrl::CEATA_DEVICE_INTERRUPT_STATUS_R">CEATA_DEVICE_INTERRUPT_STATUS_R</a></div><div class="desc docblock-short">Field <code>CEATA_DEVICE_INTERRUPT_STATUS</code> reader - Software should appropriately write to this bit after the power-on reset or any other reset to the CE-ATA device. After reset, the CE-ATA device’s interrupt is usually disabled (nIEN = 1). If the host enables the CE-ATA device’s interrupt, then software should set this bit.</div></li><li><div class="item-name"><a class="type" href="type.CEATA_DEVICE_INTERRUPT_STATUS_W.html" title="type esp32::sdhost::ctrl::CEATA_DEVICE_INTERRUPT_STATUS_W">CEATA_DEVICE_INTERRUPT_STATUS_W</a></div><div class="desc docblock-short">Field <code>CEATA_DEVICE_INTERRUPT_STATUS</code> writer - Software should appropriately write to this bit after the power-on reset or any other reset to the CE-ATA device. After reset, the CE-ATA device’s interrupt is usually disabled (nIEN = 1). If the host enables the CE-ATA device’s interrupt, then software should set this bit.</div></li><li><div class="item-name"><a class="type" href="type.CONTROLLER_RESET_R.html" title="type esp32::sdhost::ctrl::CONTROLLER_RESET_R">CONTROLLER_RESET_R</a></div><div class="desc docblock-short">Field <code>CONTROLLER_RESET</code> reader - To reset controller, firmware should set this bit. This bit is auto-cleared after two AHB and two sdhost_cclk_in clock cycles.</div></li><li><div class="item-name"><a class="type" href="type.CONTROLLER_RESET_W.html" title="type esp32::sdhost::ctrl::CONTROLLER_RESET_W">CONTROLLER_RESET_W</a></div><div class="desc docblock-short">Field <code>CONTROLLER_RESET</code> writer - To reset controller, firmware should set this bit. This bit is auto-cleared after two AHB and two sdhost_cclk_in clock cycles.</div></li><li><div class="item-name"><a class="type" href="type.DMA_RESET_R.html" title="type esp32::sdhost::ctrl::DMA_RESET_R">DMA_RESET_R</a></div><div class="desc docblock-short">Field <code>DMA_RESET</code> reader - To reset DMA interface, firmware should set bit to 1. This bit is auto-cleared after two AHB clocks.</div></li><li><div class="item-name"><a class="type" href="type.DMA_RESET_W.html" title="type esp32::sdhost::ctrl::DMA_RESET_W">DMA_RESET_W</a></div><div class="desc docblock-short">Field <code>DMA_RESET</code> writer - To reset DMA interface, firmware should set bit to 1. This bit is auto-cleared after two AHB clocks.</div></li><li><div class="item-name"><a class="type" href="type.FIFO_RESET_R.html" title="type esp32::sdhost::ctrl::FIFO_RESET_R">FIFO_RESET_R</a></div><div class="desc docblock-short">Field <code>FIFO_RESET</code> reader - To reset FIFO, firmware should set bit to 1. This bit is auto-cleared after completion of reset operation. Note: FIFO pointers will be out of reset after 2 cycles of system clocks in addition to synchronization delay (2 cycles of card clock), after the fifo_reset is cleared.</div></li><li><div class="item-name"><a class="type" href="type.FIFO_RESET_W.html" title="type esp32::sdhost::ctrl::FIFO_RESET_W">FIFO_RESET_W</a></div><div class="desc docblock-short">Field <code>FIFO_RESET</code> writer - To reset FIFO, firmware should set bit to 1. This bit is auto-cleared after completion of reset operation. Note: FIFO pointers will be out of reset after 2 cycles of system clocks in addition to synchronization delay (2 cycles of card clock), after the fifo_reset is cleared.</div></li><li><div class="item-name"><a class="type" href="type.INT_ENABLE_R.html" title="type esp32::sdhost::ctrl::INT_ENABLE_R">INT_ENABLE_R</a></div><div class="desc docblock-short">Field <code>INT_ENABLE</code> reader - Global interrupt enable/disable bit. 0: Disable; 1: Enable.</div></li><li><div class="item-name"><a class="type" href="type.INT_ENABLE_W.html" title="type esp32::sdhost::ctrl::INT_ENABLE_W">INT_ENABLE_W</a></div><div class="desc docblock-short">Field <code>INT_ENABLE</code> writer - Global interrupt enable/disable bit. 0: Disable; 1: Enable.</div></li><li><div class="item-name"><a class="type" href="type.R.html" title="type esp32::sdhost::ctrl::R">R</a></div><div class="desc docblock-short">Register <code>CTRL</code> reader</div></li><li><div class="item-name"><a class="type" href="type.READ_WAIT_R.html" title="type esp32::sdhost::ctrl::READ_WAIT_R">READ_WAIT_R</a></div><div class="desc docblock-short">Field <code>READ_WAIT</code> reader - For sending read-wait to SDIO cards.</div></li><li><div class="item-name"><a class="type" href="type.READ_WAIT_W.html" title="type esp32::sdhost::ctrl::READ_WAIT_W">READ_WAIT_W</a></div><div class="desc docblock-short">Field <code>READ_WAIT</code> writer - For sending read-wait to SDIO cards.</div></li><li><div class="item-name"><a class="type" href="type.SEND_AUTO_STOP_CCSD_R.html" title="type esp32::sdhost::ctrl::SEND_AUTO_STOP_CCSD_R">SEND_AUTO_STOP_CCSD_R</a></div><div class="desc docblock-short">Field <code>SEND_AUTO_STOP_CCSD</code> reader - Always Set SDHOST_SEND_AUTO_STOP_CCSD and SDHOST_SEND_CCSD bits together; SDHOST_SEND_AUTO_STOP_CCSD should not be set independently of send_ccsd. When set, SD/MMC automatically sends an internally-generated STOP command (CMD12) to the CE-ATA device. After sending this internally-generated STOP command, the Auto Command Done (ACD) bit in SDHOST_RINTSTS_REG is set and an interrupt is generated for the host, in case the ACD interrupt is not masked. After sending the Command Completion Signal Disable (CCSD), SD/MMC automatically clears the SDHOST_SEND_AUTO_STOP_CCSD bit.</div></li><li><div class="item-name"><a class="type" href="type.SEND_AUTO_STOP_CCSD_W.html" title="type esp32::sdhost::ctrl::SEND_AUTO_STOP_CCSD_W">SEND_AUTO_STOP_CCSD_W</a></div><div class="desc docblock-short">Field <code>SEND_AUTO_STOP_CCSD</code> writer - Always Set SDHOST_SEND_AUTO_STOP_CCSD and SDHOST_SEND_CCSD bits together; SDHOST_SEND_AUTO_STOP_CCSD should not be set independently of send_ccsd. When set, SD/MMC automatically sends an internally-generated STOP command (CMD12) to the CE-ATA device. After sending this internally-generated STOP command, the Auto Command Done (ACD) bit in SDHOST_RINTSTS_REG is set and an interrupt is generated for the host, in case the ACD interrupt is not masked. After sending the Command Completion Signal Disable (CCSD), SD/MMC automatically clears the SDHOST_SEND_AUTO_STOP_CCSD bit.</div></li><li><div class="item-name"><a class="type" href="type.SEND_CCSD_R.html" title="type esp32::sdhost::ctrl::SEND_CCSD_R">SEND_CCSD_R</a></div><div class="desc docblock-short">Field <code>SEND_CCSD</code> reader - When set, SD/MMC sends CCSD to the CE-ATA device. Software sets this bit only if the current command is expecting CCS (that is, RW_BLK), and if interrupts are enabled for the CE-ATA device. Once the CCSD pattern is sent to the device, SD/MMC automatically clears the SDHOST_SEND_CCSD bit. It also sets the Command Done (CD) bit in the SDHOST_RINTSTS_REG register, and generates an interrupt for the host, in case the Command Done interrupt is not masked. NOTE: Once the SDHOST_SEND_CCSD bit is set, it takes two card clock cycles to drive the CCSD on the CMD line. Due to this, within the boundary conditions the CCSD may be sent to the CE-ATA device, even if the device has signalled CCS.</div></li><li><div class="item-name"><a class="type" href="type.SEND_CCSD_W.html" title="type esp32::sdhost::ctrl::SEND_CCSD_W">SEND_CCSD_W</a></div><div class="desc docblock-short">Field <code>SEND_CCSD</code> writer - When set, SD/MMC sends CCSD to the CE-ATA device. Software sets this bit only if the current command is expecting CCS (that is, RW_BLK), and if interrupts are enabled for the CE-ATA device. Once the CCSD pattern is sent to the device, SD/MMC automatically clears the SDHOST_SEND_CCSD bit. It also sets the Command Done (CD) bit in the SDHOST_RINTSTS_REG register, and generates an interrupt for the host, in case the Command Done interrupt is not masked. NOTE: Once the SDHOST_SEND_CCSD bit is set, it takes two card clock cycles to drive the CCSD on the CMD line. Due to this, within the boundary conditions the CCSD may be sent to the CE-ATA device, even if the device has signalled CCS.</div></li><li><div class="item-name"><a class="type" href="type.SEND_IRQ_RESPONSE_R.html" title="type esp32::sdhost::ctrl::SEND_IRQ_RESPONSE_R">SEND_IRQ_RESPONSE_R</a></div><div class="desc docblock-short">Field <code>SEND_IRQ_RESPONSE</code> reader - Bit automatically clears once response is sent. To wait for MMC card interrupts, host issues CMD40 and waits for interrupt response from MMC card(s). In the meantime, if host wants SD/MMC to exit waiting for interrupt state, it can set this bit, at which time SD/MMC command state-machine sends CMD40 response on bus and returns to idle state.</div></li><li><div class="item-name"><a class="type" href="type.SEND_IRQ_RESPONSE_W.html" title="type esp32::sdhost::ctrl::SEND_IRQ_RESPONSE_W">SEND_IRQ_RESPONSE_W</a></div><div class="desc docblock-short">Field <code>SEND_IRQ_RESPONSE</code> writer - Bit automatically clears once response is sent. To wait for MMC card interrupts, host issues CMD40 and waits for interrupt response from MMC card(s). In the meantime, if host wants SD/MMC to exit waiting for interrupt state, it can set this bit, at which time SD/MMC command state-machine sends CMD40 response on bus and returns to idle state.</div></li><li><div class="item-name"><a class="type" href="type.W.html" title="type esp32::sdhost::ctrl::W">W</a></div><div class="desc docblock-short">Register <code>CTRL</code> writer</div></li></ul></section></div></main></body></html>