// Do NOT edit this file directly. Make your changes to esp-metadata,
// then run `cargo xtask update-metadata`.

/// The name of the chip as `&str`
///
/// # Example
///
/// ```rust, no_run
/// use esp_hal::chip;
/// let chip_name = chip!();
#[doc = concat!("assert_eq!(chip_name, ", chip!(), ")")]
/// ```
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! chip {
    () => {
        "esp32c61"
    };
}
/// The properties of this chip and its drivers.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! property {
    ("chip") => {
        "esp32c61"
    };
    ("arch") => {
        "riscv"
    };
    ("cores") => {
        1
    };
    ("cores", str) => {
        stringify!(1)
    };
    ("trm") => {
        "https://www.espressif.com/sites/default/files/documentation/esp32-c61_technical_reference_manual_en.pdf"
    };
    ("gpio.has_bank_1") => {
        false
    };
    ("gpio.gpio_function") => {
        1
    };
    ("gpio.gpio_function", str) => {
        stringify!(1)
    };
    ("gpio.constant_0_input") => {
        96
    };
    ("gpio.constant_0_input", str) => {
        stringify!(96)
    };
    ("gpio.constant_1_input") => {
        64
    };
    ("gpio.constant_1_input", str) => {
        stringify!(64)
    };
    ("gpio.remap_iomux_pin_registers") => {
        false
    };
    ("gpio.func_in_sel_offset") => {
        0
    };
    ("gpio.func_in_sel_offset", str) => {
        stringify!(0)
    };
    ("gpio.input_signal_max") => {
        100
    };
    ("gpio.input_signal_max", str) => {
        stringify!(100)
    };
    ("gpio.output_signal_max") => {
        256
    };
    ("gpio.output_signal_max", str) => {
        stringify!(256)
    };
    ("i2c_master.has_fsm_timeouts") => {
        true
    };
    ("i2c_master.has_hw_bus_clear") => {
        true
    };
    ("i2c_master.has_bus_timeout_enable") => {
        true
    };
    ("i2c_master.separate_filter_config_registers") => {
        false
    };
    ("i2c_master.can_estimate_nack_reason") => {
        true
    };
    ("i2c_master.has_conf_update") => {
        true
    };
    ("i2c_master.has_reliable_fsm_reset") => {
        true
    };
    ("i2c_master.has_arbitration_en") => {
        true
    };
    ("i2c_master.has_tx_fifo_watermark") => {
        true
    };
    ("i2c_master.bus_timeout_is_exponential") => {
        true
    };
    ("i2c_master.max_bus_timeout") => {
        31
    };
    ("i2c_master.max_bus_timeout", str) => {
        stringify!(31)
    };
    ("i2c_master.ll_intr_mask") => {
        16383
    };
    ("i2c_master.ll_intr_mask", str) => {
        stringify!(16383)
    };
    ("i2c_master.fifo_size") => {
        32
    };
    ("i2c_master.fifo_size", str) => {
        stringify!(32)
    };
    ("interrupts.status_registers") => {
        3
    };
    ("interrupts.status_registers", str) => {
        stringify!(3)
    };
    ("spi_master.has_octal") => {
        false
    };
}
/// Macro to get the address range of the given memory region.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! memory_range {
    ("DRAM") => {
        1082130432..1082458112
    };
}
/// This macro can be used to generate code for each peripheral instance of the I2C master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $scl:ident, $sda:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the I2C instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$scl`, `$sda`: peripheral signal names.
///
/// Example data: `(I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_i2c_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA));
        _for_each_inner!((all(I2C0, I2cExt0, I2CEXT0_SCL, I2CEXT0_SDA)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the UART driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $rx:ident, $tx:ident, $cts:ident, $rts:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the UART instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$rx`, `$tx`, `$cts`, `$rts`: signal names.
///
/// Example data: `(UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_uart {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS));
        _for_each_inner!((UART1, Uart1, U1RXD, U1TXD, U1CTS, U1RTS));
        _for_each_inner!((all(UART0, Uart0, U0RXD, U0TXD, U0CTS, U0RTS), (UART1, Uart1,
        U1RXD, U1TXD, U1CTS, U1RTS)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI master driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident, [$($cs:ident),*] [$($sio:ident),*
/// $($is_qspi:iteral)?])`
///
/// Macro fragments:
///
/// - `$instance`: the name of the SPI instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$cs`, `$sio`: chip select and SIO signal names.
/// - `$is_qspi`: a `true` literal present if the SPI instance supports QSPI.
///
/// Example data:
/// - `(SPI2, Spi2, FSPICLK [FSPICS0, FSPICS1, FSPICS2, FSPICS3, FSPICS4, FSPICS5] [FSPID, FSPIQ,
///   FSPIWP, FSPIHD, FSPIIO4, FSPIIO5, FSPIIO6, FSPIIO7], true)`
/// - `(SPI3, Spi3, SPI3_CLK [SPI3_CS0, SPI3_CS1, SPI3_CS2] [SPI3_D, SPI3_Q])`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_master {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((SPI2, Spi2, FSPICLK[FSPICS0, FSPICS1, FSPICS2, FSPICS3,
        FSPICS4, FSPICS5] [FSPID, FSPIQ, FSPIWP, FSPIHD], true));
        _for_each_inner!((all(SPI2, Spi2, FSPICLK[FSPICS0, FSPICS1, FSPICS2, FSPICS3,
        FSPICS4, FSPICS5] [FSPID, FSPIQ, FSPIWP, FSPIHD], true)));
    };
}
/// This macro can be used to generate code for each peripheral instance of the SPI slave driver.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($instance:ident, $sys:ident, $sclk:ident, $mosi:ident, $miso:ident, $cs:ident)`
///
/// Macro fragments:
///
/// - `$instance`: the name of the I2C instance
/// - `$sys`: the name of the instance as it is in the `esp_hal::system::Peripheral` enum.
/// - `$mosi`, `$miso`, `$cs`: signal names.
///
/// Example data: `(SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0)`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_spi_slave {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0));
        _for_each_inner!((all(SPI2, Spi2, FSPICLK, FSPID, FSPIQ, FSPICS0)));
    };
}
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_peripheral {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((GPIO0 <= virtual())); _for_each_inner!((GPIO1 <= virtual()));
        _for_each_inner!((GPIO2 <= virtual())); _for_each_inner!((GPIO3 <= virtual()));
        _for_each_inner!((GPIO4 <= virtual())); _for_each_inner!((GPIO5 <= virtual()));
        _for_each_inner!((GPIO6 <= virtual())); _for_each_inner!((GPIO7 <= virtual()));
        _for_each_inner!((GPIO8 <= virtual())); _for_each_inner!((GPIO9 <= virtual()));
        _for_each_inner!((GPIO10 <= virtual())); _for_each_inner!((GPIO11 <= virtual()));
        _for_each_inner!((GPIO12 <= virtual())); _for_each_inner!((GPIO13 <= virtual()));
        _for_each_inner!((GPIO22 <= virtual())); _for_each_inner!((GPIO23 <= virtual()));
        _for_each_inner!((GPIO24 <= virtual())); _for_each_inner!((GPIO25 <= virtual()));
        _for_each_inner!((GPIO26 <= virtual())); _for_each_inner!((GPIO27 <= virtual()));
        _for_each_inner!((GPIO28 <= virtual())); _for_each_inner!((GPIO <= GPIO()
        (unstable))); _for_each_inner!((I2C0 <= I2C0(I2C_EXT0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }))); _for_each_inner!((IO_MUX <=
        IO_MUX() (unstable))); _for_each_inner!((INTERRUPT_CORE0 <= INTERRUPT_CORE0()
        (unstable))); _for_each_inner!((INTPRI <= INTPRI() (unstable)));
        _for_each_inner!((LP_AON <= LP_AON() (unstable))); _for_each_inner!((LP_IO <=
        LP_IO() (unstable))); _for_each_inner!((LP_IO_MUX <= LP_IO_MUX() (unstable)));
        _for_each_inner!((PCR <= PCR() (unstable))); _for_each_inner!((SPI0 <= SPI0()
        (unstable))); _for_each_inner!((SPI1 <= SPI1() (unstable)));
        _for_each_inner!((SPI2 <= SPI2(SPI2 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }))); _for_each_inner!((SYSTEM <=
        PCR() (unstable))); _for_each_inner!((SYSTIMER <= SYSTIMER() (unstable)));
        _for_each_inner!((UART0 <= UART0(UART0 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt }))); _for_each_inner!((UART1 <=
        UART1(UART1 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt }))); _for_each_inner!((DMA_CH0 <= virtual() (unstable)));
        _for_each_inner!((DMA_CH1 <= virtual() (unstable))); _for_each_inner!((DMA_CH2 <=
        virtual() (unstable))); _for_each_inner!((SW_INTERRUPT <= virtual() (unstable)));
        _for_each_inner!((all(GPIO0 <= virtual()), (GPIO1 <= virtual()), (GPIO2 <=
        virtual()), (GPIO3 <= virtual()), (GPIO4 <= virtual()), (GPIO5 <= virtual()),
        (GPIO6 <= virtual()), (GPIO7 <= virtual()), (GPIO8 <= virtual()), (GPIO9 <=
        virtual()), (GPIO10 <= virtual()), (GPIO11 <= virtual()), (GPIO12 <= virtual()),
        (GPIO13 <= virtual()), (GPIO22 <= virtual()), (GPIO23 <= virtual()), (GPIO24 <=
        virtual()), (GPIO25 <= virtual()), (GPIO26 <= virtual()), (GPIO27 <= virtual()),
        (GPIO28 <= virtual()), (GPIO <= GPIO() (unstable)), (I2C0 <= I2C0(I2C_EXT0 : {
        bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt })), (IO_MUX
        <= IO_MUX() (unstable)), (INTERRUPT_CORE0 <= INTERRUPT_CORE0() (unstable)),
        (INTPRI <= INTPRI() (unstable)), (LP_AON <= LP_AON() (unstable)), (LP_IO <=
        LP_IO() (unstable)), (LP_IO_MUX <= LP_IO_MUX() (unstable)), (PCR <= PCR()
        (unstable)), (SPI0 <= SPI0() (unstable)), (SPI1 <= SPI1() (unstable)), (SPI2 <=
        SPI2(SPI2 : { bind_peri_interrupt, enable_peri_interrupt, disable_peri_interrupt
        })), (SYSTEM <= PCR() (unstable)), (SYSTIMER <= SYSTIMER() (unstable)), (UART0 <=
        UART0(UART0 : { bind_peri_interrupt, enable_peri_interrupt,
        disable_peri_interrupt })), (UART1 <= UART1(UART1 : { bind_peri_interrupt,
        enable_peri_interrupt, disable_peri_interrupt })), (DMA_CH0 <= virtual()
        (unstable)), (DMA_CH1 <= virtual() (unstable)), (DMA_CH2 <= virtual()
        (unstable)), (SW_INTERRUPT <= virtual() (unstable))));
    };
}
/// This macro can be used to generate code for each `GPIOn` instance.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has one option for its "Individual matcher" case:
///
/// Syntax: `($n:literal, $gpio:ident ($($digital_input_function:ident =>
/// $digital_input_signal:ident)*) ($($digital_output_function:ident =>
/// $digital_output_signal:ident)*) ($([$pin_attribute:ident])*))`
///
/// Macro fragments:
///
/// - `$n`: the number of the GPIO. For `GPIO0`, `$n` is 0.
/// - `$gpio`: the name of the GPIO.
/// - `$digital_input_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_input_function`: the name of the digital function, as an identifier.
/// - `$digital_output_function`: the number of the digital function, as an identifier (i.e. for
///   function 0 this is `_0`).
/// - `$digital_output_function`: the name of the digital function, as an identifier.
/// - `$pin_attribute`: `Input` and/or `Output`, marks the possible directions of the GPIO.
///   Bracketed so that they can also be matched as optional fragments. Order is always Input first.
///
/// Example data: `(0, GPIO0 (_5 => EMAC_TX_CLK) (_1 => CLK_OUT1 _5 => EMAC_TX_CLK) ([Input]
/// [Output]))`
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_gpio {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((0, GPIO0() () ([Input] [Output]))); _for_each_inner!((1,
        GPIO1() () ([Input] [Output]))); _for_each_inner!((2, GPIO2(_2 => FSPIQ) (_2 =>
        FSPIQ) ([Input] [Output]))); _for_each_inner!((3, GPIO3(_0 => MTMS _2 => FSPIHD)
        (_2 => FSPIHD) ([Input] [Output]))); _for_each_inner!((4, GPIO4(_0 => MTDI _2 =>
        FSPIWP) (_2 => FSPIWP) ([Input] [Output]))); _for_each_inner!((5, GPIO5(_0 =>
        MTCK) () ([Input] [Output]))); _for_each_inner!((6, GPIO6(_0 => MTDO _2 =>
        FSPICLK) (_2 => FSPICLK) ([Input] [Output]))); _for_each_inner!((7, GPIO7(_2 =>
        FSPID) (_2 => FSPID) ([Input] [Output]))); _for_each_inner!((8, GPIO8(_2 =>
        FSPICS0) (_2 => FSPICS0) ([Input] [Output]))); _for_each_inner!((9, GPIO9() ()
        ([Input] [Output]))); _for_each_inner!((10, GPIO10(_0 => U0RXD _2 => FSPICS0) (_2
        => FSPICS0) ([Input] [Output]))); _for_each_inner!((11, GPIO11() (_0 => U0TXD)
        ([Input] [Output]))); _for_each_inner!((12, GPIO12() () ([Input] [Output])));
        _for_each_inner!((13, GPIO13() () ([Input] [Output]))); _for_each_inner!((22,
        GPIO22(_0 => SDIO_DATA2) () ([Input] [Output]))); _for_each_inner!((23, GPIO23(_0
        => SDIO_DATA3) () ([Input] [Output]))); _for_each_inner!((24, GPIO24() ()
        ([Input] [Output]))); _for_each_inner!((25, GPIO25(_0 => SDIO_CMD) () ([Input]
        [Output]))); _for_each_inner!((26, GPIO26(_0 => SDIO_CLK) () ([Input]
        [Output]))); _for_each_inner!((27, GPIO27(_0 => SDIO_DATA0) () ([Input]
        [Output]))); _for_each_inner!((28, GPIO28(_0 => SDIO_DATA1) () ([Input]
        [Output]))); _for_each_inner!((all(0, GPIO0() () ([Input] [Output])), (1, GPIO1()
        () ([Input] [Output])), (2, GPIO2(_2 => FSPIQ) (_2 => FSPIQ) ([Input] [Output])),
        (3, GPIO3(_0 => MTMS _2 => FSPIHD) (_2 => FSPIHD) ([Input] [Output])), (4,
        GPIO4(_0 => MTDI _2 => FSPIWP) (_2 => FSPIWP) ([Input] [Output])), (5, GPIO5(_0
        => MTCK) () ([Input] [Output])), (6, GPIO6(_0 => MTDO _2 => FSPICLK) (_2 =>
        FSPICLK) ([Input] [Output])), (7, GPIO7(_2 => FSPID) (_2 => FSPID) ([Input]
        [Output])), (8, GPIO8(_2 => FSPICS0) (_2 => FSPICS0) ([Input] [Output])), (9,
        GPIO9() () ([Input] [Output])), (10, GPIO10(_0 => U0RXD _2 => FSPICS0) (_2 =>
        FSPICS0) ([Input] [Output])), (11, GPIO11() (_0 => U0TXD) ([Input] [Output])),
        (12, GPIO12() () ([Input] [Output])), (13, GPIO13() () ([Input] [Output])), (22,
        GPIO22(_0 => SDIO_DATA2) () ([Input] [Output])), (23, GPIO23(_0 => SDIO_DATA3) ()
        ([Input] [Output])), (24, GPIO24() () ([Input] [Output])), (25, GPIO25(_0 =>
        SDIO_CMD) () ([Input] [Output])), (26, GPIO26(_0 => SDIO_CLK) () ([Input]
        [Output])), (27, GPIO27(_0 => SDIO_DATA0) () ([Input] [Output])), (28, GPIO28(_0
        => SDIO_DATA1) () ([Input] [Output]))));
    };
}
/// This macro can be used to generate code for each analog function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `ADC2_CH3` the expanded form looks like
///   `(ADC2_CH3, ADCn_CHm, 2, 3)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(ADC2_CH5, GPIO12)`
/// - `((ADC2_CH5, ADCn_CHm, 2, 5), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_analog_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((XTAL_32K_P, GPIO0)); _for_each_inner!((XTAL_32K_N, GPIO1));
        _for_each_inner!((ADC1_CH0, GPIO1)); _for_each_inner!((ADC1_CH1, GPIO3));
        _for_each_inner!((ADC1_CH2, GPIO4)); _for_each_inner!((ADC1_CH3, GPIO5));
        _for_each_inner!((ZCD0, GPIO8)); _for_each_inner!((ZCD1, GPIO9));
        _for_each_inner!((USB_DM, GPIO12)); _for_each_inner!((USB_DP, GPIO13));
        _for_each_inner!(((ADC1_CH0, ADCn_CHm, 1, 0), GPIO1));
        _for_each_inner!(((ADC1_CH1, ADCn_CHm, 1, 1), GPIO3));
        _for_each_inner!(((ADC1_CH2, ADCn_CHm, 1, 2), GPIO4));
        _for_each_inner!(((ADC1_CH3, ADCn_CHm, 1, 3), GPIO5)); _for_each_inner!(((ZCD0,
        ZCDn, 0), GPIO8)); _for_each_inner!(((ZCD1, ZCDn, 1), GPIO9));
        _for_each_inner!((all(XTAL_32K_P, GPIO0), (XTAL_32K_N, GPIO1), (ADC1_CH0, GPIO1),
        (ADC1_CH1, GPIO3), (ADC1_CH2, GPIO4), (ADC1_CH3, GPIO5), (ZCD0, GPIO8), (ZCD1,
        GPIO9), (USB_DM, GPIO12), (USB_DP, GPIO13)));
        _for_each_inner!((all_expanded((ADC1_CH0, ADCn_CHm, 1, 0), GPIO1), ((ADC1_CH1,
        ADCn_CHm, 1, 1), GPIO3), ((ADC1_CH2, ADCn_CHm, 1, 2), GPIO4), ((ADC1_CH3,
        ADCn_CHm, 1, 3), GPIO5), ((ZCD0, ZCDn, 0), GPIO8), ((ZCD1, ZCDn, 1), GPIO9)));
    };
}
/// This macro can be used to generate code for each LP/RTC function of each GPIO.
///
/// For an explanation on the general syntax, as well as usage of individual/repeated
/// matchers, refer to [the crate-level documentation][crate#for_each-macros].
///
/// This macro has two options for its "Individual matcher" case:
///
/// - `all`: `($signal:ident, $gpio:ident)` - simple case where you only need identifiers
/// - `all_expanded`: `(($signal:ident, $group:ident $(, $number:literal)+), $gpio:ident)` -
///   expanded signal case, where you need the number(s) of a signal, or the general group to which
///   the signal belongs. For example, in case of `SAR_I2C_SCL_1` the expanded form looks like
///   `(SAR_I2C_SCL_1, SAR_I2C_SCL_n, 1)`.
///
/// Macro fragments:
///
/// - `$signal`: the name of the signal.
/// - `$group`: the name of the signal, with numbers replaced by placeholders. For `ADC2_CH3` this
///   is `ADCn_CHm`.
/// - `$number`: the numbers extracted from `$signal`.
/// - `$gpio`: the name of the GPIO.
///
/// Example data:
/// - `(RTC_GPIO15, GPIO12)`
/// - `((RTC_GPIO15, RTC_GPIOn, 15), GPIO12)`
///
/// The expanded syntax is only available when the signal has at least one numbered component.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! for_each_lp_function {
    ($($pattern:tt => $code:tt;)*) => {
        macro_rules! _for_each_inner { $(($pattern) => $code;)* ($other : tt) => {} }
        _for_each_inner!((LP_UART_DTRN, GPIO0)); _for_each_inner!((LP_GPIO0, GPIO0));
        _for_each_inner!((LP_UART_DSRN, GPIO1)); _for_each_inner!((LP_GPIO1, GPIO1));
        _for_each_inner!((LP_UART_RTSN, GPIO2)); _for_each_inner!((LP_GPIO2, GPIO2));
        _for_each_inner!((LP_I2C_SDA, GPIO2)); _for_each_inner!((LP_UART_CTSN, GPIO3));
        _for_each_inner!((LP_GPIO3, GPIO3)); _for_each_inner!((LP_I2C_SCL, GPIO3));
        _for_each_inner!((LP_UART_RXD_PAD, GPIO4)); _for_each_inner!((LP_GPIO4, GPIO4));
        _for_each_inner!((LP_UART_TXD_PAD, GPIO5)); _for_each_inner!((LP_GPIO5, GPIO5));
        _for_each_inner!(((LP_GPIO0, LP_GPIOn, 0), GPIO0)); _for_each_inner!(((LP_GPIO1,
        LP_GPIOn, 1), GPIO1)); _for_each_inner!(((LP_GPIO2, LP_GPIOn, 2), GPIO2));
        _for_each_inner!(((LP_GPIO3, LP_GPIOn, 3), GPIO3)); _for_each_inner!(((LP_GPIO4,
        LP_GPIOn, 4), GPIO4)); _for_each_inner!(((LP_GPIO5, LP_GPIOn, 5), GPIO5));
        _for_each_inner!((all(LP_UART_DTRN, GPIO0), (LP_GPIO0, GPIO0), (LP_UART_DSRN,
        GPIO1), (LP_GPIO1, GPIO1), (LP_UART_RTSN, GPIO2), (LP_GPIO2, GPIO2), (LP_I2C_SDA,
        GPIO2), (LP_UART_CTSN, GPIO3), (LP_GPIO3, GPIO3), (LP_I2C_SCL, GPIO3),
        (LP_UART_RXD_PAD, GPIO4), (LP_GPIO4, GPIO4), (LP_UART_TXD_PAD, GPIO5), (LP_GPIO5,
        GPIO5))); _for_each_inner!((all_expanded((LP_GPIO0, LP_GPIOn, 0), GPIO0),
        ((LP_GPIO1, LP_GPIOn, 1), GPIO1), ((LP_GPIO2, LP_GPIOn, 2), GPIO2), ((LP_GPIO3,
        LP_GPIOn, 3), GPIO3), ((LP_GPIO4, LP_GPIOn, 4), GPIO4), ((LP_GPIO5, LP_GPIOn, 5),
        GPIO5)));
    };
}
/// Defines the `InputSignal` and `OutputSignal` enums.
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_signals {
    () => {
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum InputSignal {
            U0RXD               = 6,
            U0CTS               = 7,
            U0DSR               = 8,
            U1RXD               = 9,
            U1CTS               = 10,
            U1DSR               = 11,
            I2S_MCLK            = 12,
            I2SO_BCK            = 13,
            I2SO_WS             = 14,
            I2SI_SD             = 15,
            I2SI_BCK            = 16,
            I2SI_WS             = 17,
            CPU_GPIO_IN0        = 27,
            CPU_GPIO_IN1        = 28,
            CPU_GPIO_IN2        = 29,
            CPU_GPIO_IN3        = 30,
            CPU_GPIO_IN4        = 31,
            CPU_GPIO_IN5        = 32,
            CPU_GPIO_IN6        = 33,
            CPU_GPIO_IN7        = 34,
            USB_JTAG_TDO_BRIDGE = 35,
            I2CEXT0_SCL         = 46,
            I2CEXT0_SDA         = 47,
            FSPICLK             = 64,
            FSPIQ               = 65,
            FSPID               = 66,
            FSPIHD              = 67,
            FSPIWP              = 68,
            FSPICS0             = 69,
            U2RXD               = 72,
            U2CTS               = 73,
            U2DSR               = 74,
            SIG_IN_FUNC97       = 97,
            SIG_IN_FUNC98       = 98,
            SIG_IN_FUNC99       = 99,
            SIG_IN_FUNC100      = 100,
            SDIO_CLK,
            SDIO_CMD,
            SDIO_DATA0,
            SDIO_DATA1,
            SDIO_DATA2,
            SDIO_DATA3,
            MTDI,
            MTDO,
            MTCK,
            MTMS,
        }
        #[allow(non_camel_case_types, clippy::upper_case_acronyms)]
        #[derive(Debug, PartialEq, Copy, Clone)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[doc(hidden)]
        pub enum OutputSignal {
            LEDC_LS_SIG0   = 0,
            LEDC_LS_SIG1   = 1,
            LEDC_LS_SIG2   = 2,
            LEDC_LS_SIG3   = 3,
            LEDC_LS_SIG4   = 4,
            LEDC_LS_SIG5   = 5,
            U0TXD          = 6,
            U0RTS          = 7,
            U0DTR          = 8,
            U1TXD          = 9,
            U1RTS          = 10,
            U1DTR          = 11,
            I2S_MCLK       = 12,
            I2SO_BCK       = 13,
            I2SO_WS        = 14,
            I2SO_SD        = 15,
            I2SI_BCK       = 16,
            I2SI_WS        = 17,
            I2SO_SD1       = 18,
            CPU_GPIO_OUT0  = 27,
            CPU_GPIO_OUT1  = 28,
            CPU_GPIO_OUT2  = 29,
            CPU_GPIO_OUT3  = 30,
            CPU_GPIO_OUT4  = 31,
            CPU_GPIO_OUT5  = 32,
            CPU_GPIO_OUT6  = 33,
            CPU_GPIO_OUT7  = 34,
            I2CEXT0_SCL    = 46,
            I2CEXT0_SDA    = 47,
            FSPICLK        = 64,
            FSPIQ          = 65,
            FSPID          = 66,
            FSPIHD         = 67,
            FSPIWP         = 68,
            FSPICS0        = 69,
            U2RXD          = 72,
            U2CTS          = 73,
            U2DSR          = 74,
            SIG_IN_FUNC97  = 97,
            SIG_IN_FUNC98  = 98,
            SIG_IN_FUNC99  = 99,
            SIG_IN_FUNC100 = 100,
            FSPICS1        = 102,
            FSPICS2        = 103,
            FSPICS3        = 104,
            FSPICS4        = 105,
            FSPICS5        = 106,
            GPIO           = 256,
        }
    };
}
/// Defines and implements the `io_mux_reg` function.
///
/// The generated function has the following signature:
///
/// ```rust,ignore
/// pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO0 {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// This macro is intended to be called in esp-hal only.
#[macro_export]
#[expect(clippy::crate_in_macro_def)]
#[cfg_attr(docsrs, doc(cfg(feature = "_device-selected")))]
macro_rules! define_io_mux_reg {
    () => {
        pub(crate) fn io_mux_reg(gpio_num: u8) -> &'static crate::pac::io_mux::GPIO {
            crate::peripherals::IO_MUX::regs().gpio(gpio_num as usize)
        }
    };
}
